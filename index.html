<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Snake</title>
  <style>
    :root {
      --bg: #0b0f14;
      --panel: #121925;
      --accent: #35ff8a;
      --accent-2: #19b8ff;
      --text: #e6edf3;
      --muted: #7a8699;
      --danger: #ff5c70;
    }

    * { box-sizing: border-box; }

    html, body {
      height: 100%;
      margin: 0;
      font-family: "Trebuchet MS", "Segoe UI", sans-serif;
      background: radial-gradient(circle at 30% 20%, #141b2a 0%, #0b0f14 55%, #07090d 100%);
      color: var(--text);
    }

    .app {
      min-height: 100%;
      display: grid;
      place-items: center;
      padding: 20px;
      gap: 16px;
    }

    .hud {
      width: min(92vw, 560px);
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: var(--panel);
      border: 1px solid #1f2a3a;
      border-radius: 14px;
      padding: 12px 16px;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.35);
    }

    .hud .title {
      font-weight: 700;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      font-size: 0.9rem;
      color: var(--accent);
    }

    .hud .score {
      font-weight: 700;
      font-size: 1.1rem;
    }

    .hud .timer {
      font-weight: 700;
      font-size: 1.1rem;
      color: var(--accent-2);
    }

    .hud .meta {
      color: var(--muted);
      font-size: 0.8rem;
    }

    .canvas-wrap {
      width: min(92vw, 560px);
      aspect-ratio: 1;
      background: #0a0f17;
      border: 1px solid #1b2433;
      border-radius: 16px;
      padding: 10px;
      display: grid;
      place-items: center;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.04), 0 15px 40px rgba(0,0,0,0.45);
    }

    canvas {
      width: 100%;
      height: 100%;
      border-radius: 12px;
      background: #0b0f14;
      image-rendering: pixelated;
    }

    .controls {
      width: min(92vw, 560px);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
    }

    .controls button {
      flex: 1 1 auto;
      min-width: 120px;
      border: 1px solid #263449;
      background: #121a27;
      color: var(--text);
      padding: 10px 14px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 600;
      transition: transform 0.08s ease, background 0.2s ease;
    }

    .controls button:hover { background: #162234; }
    .controls button:active { transform: scale(0.98); }

    .controls .primary {
      background: linear-gradient(135deg, #1b2a3f, #0f1624);
      border-color: #2a3b56;
    }

    .controls .toggle {
      display: inline-flex;
      gap: 8px;
      align-items: center;
      justify-content: center;
      white-space: nowrap;
    }

    .mobile-dpad {
      width: min(92vw, 220px);
      height: 220px;
      margin-top: 6px;
      position: relative;
      border-radius: 50%;
      border: 1px solid #263449;
      background: radial-gradient(circle at 35% 30%, #19283b 0%, #101a2a 60%, #0d1522 100%);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.03);
      align-self: center;
    }

    .mobile-dpad button {
      width: 64px;
      height: 64px;
      position: absolute;
      border: 1px solid #263449;
      background: #121a27;
      color: var(--text);
      border-radius: 50%;
      font-weight: 700;
      font-size: 0.82rem;
      cursor: pointer;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    .mobile-dpad .dpad-up {
      top: 14px;
      left: 50%;
      transform: translateX(-50%);
    }

    .mobile-dpad .dpad-left {
      left: 14px;
      top: 50%;
      transform: translateY(-50%);
    }

    .mobile-dpad .dpad-down {
      bottom: 14px;
      left: 50%;
      transform: translateX(-50%);
    }

    .mobile-dpad .dpad-right {
      right: 14px;
      top: 50%;
      transform: translateY(-50%);
    }

    .mobile-dpad button:active {
      background: #162234;
      filter: brightness(1.08);
    }

    .mobile-dpad::after {
      content: "";
      position: absolute;
      width: 52px;
      height: 52px;
      border-radius: 50%;
      border: 1px solid #2c3d57;
      background: #101827;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
    }

    .message {
      text-align: center;
      color: var(--muted);
      font-size: 0.9rem;
    }

    .visitor-count {
      width: min(92vw, 560px);
      text-align: center;
      color: var(--muted);
      font-size: 0.82rem;
      border-top: 1px solid #1f2a3a;
      padding-top: 10px;
      margin-top: 6px;
    }

    .game-over {
      color: var(--danger);
      font-weight: 700;
      letter-spacing: 0.04em;
    }

    .share {
      display: none;
      width: min(92vw, 560px);
      border: 1px solid #1f3a2b;
      background: #0f2a1e;
      color: #d9ffe8;
      padding: 12px 16px;
      border-radius: 12px;
      cursor: pointer;
      font-weight: 700;
    }

    .share:hover { background: #143b2a; }

    .leaderboard {
      width: min(92vw, 560px);
      background: var(--panel);
      border: 1px solid #1f2a3a;
      border-radius: 14px;
      padding: 14px 16px;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.25);
    }

    .leaderboard-head {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 10px;
      margin-bottom: 8px;
    }

    .leaderboard-head-right {
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .leaderboard-title {
      font-weight: 700;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      font-size: 0.9rem;
      color: var(--accent);
    }

    .leaderboard-week {
      color: var(--muted);
      font-size: 0.8rem;
    }

    .leaderboard-status {
      color: var(--muted);
      font-size: 0.85rem;
      margin-bottom: 10px;
    }

    .leaderboard-toggle {
      border: 1px solid #2a3b56;
      background: #0f1624;
      color: var(--text);
      padding: 6px 10px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 700;
      font-size: 0.78rem;
      letter-spacing: 0.02em;
    }

    .leaderboard-toggle:hover { background: #162234; }

    .leaderboard.collapsed .leaderboard-body {
      display: none;
    }

    .leaderboard-list {
      margin: 0;
      padding-left: 24px;
      max-height: 220px;
      overflow: auto;
      line-height: 1.5;
      font-size: 0.95rem;
    }

    .leaderboard-labels {
      display: grid;
      grid-template-columns: 52px 1fr 72px;
      gap: 10px;
      padding: 0 14px 6px 14px;
      color: var(--muted);
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      font-weight: 700;
      text-align: center;
      border-top: 1px solid #233146;
      border-bottom: 1px solid #233146;
      margin-bottom: 4px;
    }

    .leaderboard-labels span {
      padding: 6px 0;
      border-left: 1px solid #233146;
    }

    .leaderboard-labels span:first-child {
      border-left: none;
    }

    .leaderboard-list li {
      display: grid;
      grid-template-columns: 52px 1fr 72px;
      gap: 10px;
      padding: 2px 14px;
      text-align: center;
      border-bottom: 1px solid #1f2a3a;
    }

    .leaderboard-list li > span {
      padding: 4px 0;
      border-left: 1px solid #1f2a3a;
    }

    .leaderboard-list li > span:first-child {
      border-left: none;
    }

    .leaderboard-list .rank {
      color: var(--muted);
      font-weight: 700;
    }

    .leaderboard-list .name {
      color: var(--text);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .leaderboard-list .points {
      color: var(--accent-2);
      font-weight: 700;
    }

    .leaderboard-entry {
      display: none;
      width: min(92vw, 560px);
      border: 1px solid #27563d;
      background: #0d241a;
      color: #d9ffe8;
      padding: 12px 16px;
      border-radius: 12px;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }

    .leaderboard-entry input {
      flex: 1 1 180px;
      min-width: 0;
      border: 1px solid #2d5f45;
      background: #09160f;
      color: #d9ffe8;
      padding: 9px 10px;
      border-radius: 8px;
      font-size: 0.95rem;
    }

    .leaderboard-entry button {
      border: 1px solid #2d5f45;
      background: #123220;
      color: #d9ffe8;
      padding: 9px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 700;
    }

    .leaderboard-entry button:hover { background: #18432b; }

    @media (max-width: 640px) {
      .hud { flex-direction: column; gap: 8px; align-items: flex-start; }
      .controls { flex-direction: column; }
      .controls button { width: 100%; }
      .mobile-dpad {
        width: min(92vw, 190px);
        height: 190px;
      }
      .mobile-dpad button {
        width: 56px;
        height: 56px;
      }
    }
  </style>
</head>
<body>
  <main class="app">
    <section class="leaderboard" id="leaderboardSection" aria-label="Weekly leaderboard">
      <div class="leaderboard-head">
        <div class="leaderboard-title" id="leaderboardTitle">Weekly Top 100</div>
        <div class="leaderboard-head-right">
          <div class="leaderboard-week" id="leaderboardWeek">Week --</div>
          <button class="leaderboard-toggle" id="leaderboardToggleBtn" type="button" aria-expanded="true">Collapse</button>
        </div>
      </div>
      <div class="leaderboard-body" id="leaderboardBody">
        <div class="leaderboard-status" id="leaderboardStatus">Leaderboard loading...</div>
        <div class="leaderboard-labels" aria-hidden="true">
          <span>Rank</span>
          <span>Name</span>
          <span>Score</span>
        </div>
        <ol class="leaderboard-list" id="leaderboardList"></ol>
      </div>
    </section>
    <form class="leaderboard-entry" id="leaderboardEntryForm">
      <span id="leaderboardEntryPrompt">New weekly top score. Enter your name:</span>
      <input id="leaderboardNameInput" maxlength="10" autocomplete="nickname" placeholder="Player name" required />
      <button type="submit" id="leaderboardSubmitBtn">Submit</button>
    </form>

    <section class="hud">
      <div>
        <div class="title">Neon Snake</div>
        <div class="meta">Use arrow keys or swipe</div>
      </div>
      <div class="score">Score: <span id="score">0</span></div>
      <div class="timer">Time: <span id="timer">0s / 0s</span></div>
    </section>

    <section class="canvas-wrap">
      <canvas id="game" width="600" height="600" aria-label="Snake game"></canvas>
    </section>
    <div class="message" id="message">Eat the glow cubes. Avoid walls and yourself.</div>

    <section class="mobile-dpad" id="mobileDpad" aria-label="Mobile direction pad">
      <button class="dpad-up" type="button" data-dir="up" aria-label="Move up">Up</button>
      <button class="dpad-left" type="button" data-dir="left" aria-label="Move left">Left</button>
      <button class="dpad-down" type="button" data-dir="down" aria-label="Move down">Down</button>
      <button class="dpad-right" type="button" data-dir="right" aria-label="Move right">Right</button>
    </section>
    <section class="controls">
      <button class="toggle" id="soundBtn">Sound: Off</button>
      <button id="pauseBtn">Pause</button>
      <button class="primary" id="restartBtn">Restart</button>
    </section>

    <button class="share" id="shareBtn" aria-label="Share score on WhatsApp">Share on WhatsApp</button>
    <div class="visitor-count" id="visitorCount">Unique visitors: --</div>
  </main>

  <script>
    window.SNAKE_FIREBASE_CONFIG = window.SNAKE_FIREBASE_CONFIG || {
      apiKey: "AIzaSyCrZb-G8Cvk2mUDFWabC4FrWszCUK47xaw",
      authDomain: "connect4-e2ad8.firebaseapp.com",
      projectId: "connect4-e2ad8",
      appId: "1:763431725125:web:956d260fb6a2eccd471b2c",
    };
  </script>
  <script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-firestore-compat.js"></script>
  <script>
    (function () {
      'use strict';

      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');
      const canvasWrapEl = document.querySelector('.canvas-wrap');
      const scoreEl = document.getElementById('score');
      const timerEl = document.getElementById('timer');
      const messageEl = document.getElementById('message');
      const shareBtn = document.getElementById('shareBtn');
      const restartBtn = document.getElementById('restartBtn');
      const pauseBtn = document.getElementById('pauseBtn');
      const soundBtn = document.getElementById('soundBtn');
      const visitorCountEl = document.getElementById('visitorCount');
      const mobileDpadEl = document.getElementById('mobileDpad');
      const leaderboardSectionEl = document.getElementById('leaderboardSection');
      const leaderboardBodyEl = document.getElementById('leaderboardBody');
      const leaderboardToggleBtn = document.getElementById('leaderboardToggleBtn');
      const leaderboardTitleEl = document.getElementById('leaderboardTitle');
      const leaderboardWeekEl = document.getElementById('leaderboardWeek');
      const leaderboardStatusEl = document.getElementById('leaderboardStatus');
      const leaderboardListEl = document.getElementById('leaderboardList');
      const leaderboardEntryForm = document.getElementById('leaderboardEntryForm');
      const leaderboardEntryPrompt = document.getElementById('leaderboardEntryPrompt');
      const leaderboardNameInput = document.getElementById('leaderboardNameInput');
      const leaderboardSubmitBtn = document.getElementById('leaderboardSubmitBtn');

      const gridSize = 20;
      const GRID_COLUMNS = 24; // Change this to configure playfield width in cells.
      const GRID_ROWS = 20; // Change this to configure playfield height in cells.
      const baseSpeed = 7; // cells per second
      const speedStep = 0.35; // speed increase per food
      const maxSpeed = 16;
      const GAME_DURATION_SECONDS = 60; // Change this to configure round time.
      const LEADERBOARD_LIMIT = 20; // Change this to configure weekly leaderboard size.
      const leaderboardCollection = 'snakeLeaderboardEntries';
      const visitorCollection = 'snakeVisitors';
      const visitorStatsCollection = 'snakeMeta';
      const visitorStatsDoc = 'visitorStats';
      const visitorStorageKey = 'snake_visitor_id';
      const currentWeekKey = getISOWeekKey(new Date());

      // Set window.SNAKE_FIREBASE_CONFIG before this script or replace these values directly.
      const firebaseConfig = window.SNAKE_FIREBASE_CONFIG || {
        apiKey: '',
        authDomain: '',
        projectId: '',
        appId: '',
      };

      let snake;
      let direction;
      let nextDirection;
      let food;
      let hurdles = [];
      let score;
      let lastTime = 0;
      let accumulator = 0;
      let elapsed = 0;
      let isPaused = false;
      let isGameOver = false;
      let soundEnabled = false;
      let db = null;
      let leaderboardReady = false;
      let leaderboardEntries = [];
      let pendingLeaderboardScore = null;
      let submittingLeaderboard = false;
      let leaderboardExpanded = true;

      function getTopLabel() {
        return `Top ${LEADERBOARD_LIMIT}`;
      }

      function getOrCreateVisitorId() {
        let visitorId = localStorage.getItem(visitorStorageKey);
        if (!visitorId) {
          visitorId = (window.crypto && window.crypto.randomUUID)
            ? window.crypto.randomUUID()
            : `v_${Date.now()}_${Math.random().toString(36).slice(2, 10)}`;
          localStorage.setItem(visitorStorageKey, visitorId);
        }
        return visitorId;
      }

      async function initUniqueVisitorCount() {
        if (!db) {
          visitorCountEl.textContent = 'Unique visitors: unavailable';
          return;
        }

        visitorCountEl.textContent = 'Unique visitors: loading...';
        try {
          const visitorId = getOrCreateVisitorId();
          const visitorRef = db.collection(visitorCollection).doc(visitorId);
          const statsRef = db.collection(visitorStatsCollection).doc(visitorStatsDoc);

          await db.runTransaction(async (tx) => {
            const visitorSnap = await tx.get(visitorRef);
            const statsSnap = await tx.get(statsRef);
            const currentCount = (statsSnap.exists && typeof statsSnap.data().uniqueVisitors === 'number')
              ? statsSnap.data().uniqueVisitors
              : 0;

            if (!visitorSnap.exists) {
              tx.set(visitorRef, {
                createdAtMs: Date.now(),
                firstSeenAt: firebase.firestore.FieldValue.serverTimestamp(),
              });
              tx.set(statsRef, {
                uniqueVisitors: currentCount + 1,
                updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
              }, { merge: true });
            }
          });

          const statsSnap = await db.collection(visitorStatsCollection).doc(visitorStatsDoc).get();
          const uniqueVisitors = (statsSnap.exists && typeof statsSnap.data().uniqueVisitors === 'number')
            ? statsSnap.data().uniqueVisitors
            : 0;
          visitorCountEl.textContent = `Unique visitors: ${uniqueVisitors}`;
        } catch (error) {
          console.error('Unique visitor count failed:', error);
          visitorCountEl.textContent = 'Unique visitors: unavailable';
        }
      }

      function buildHurdles() {
        const offsetX = Math.max(2, Math.floor(GRID_COLUMNS / 4));
        const offsetY = Math.max(2, Math.floor(GRID_ROWS / 4));
        const centerX = Math.floor((GRID_COLUMNS - 1) / 2);
        const centerY = Math.floor((GRID_ROWS - 1) / 2);

        const points = [
          { x: centerX - offsetX, y: centerY - offsetY },
          { x: centerX + offsetX, y: centerY - offsetY },
          { x: centerX - offsetX, y: centerY + offsetY },
          { x: centerX + offsetX, y: centerY + offsetY },
        ];

        const inBounds = (p) => (
          p.x >= 0 &&
          p.x < GRID_COLUMNS &&
          p.y >= 0 &&
          p.y < GRID_ROWS
        );
        const seen = new Set();
        return points.filter((p) => {
          if (!inBounds(p)) return false;
          const key = `${p.x},${p.y}`;
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        });
      }

      function isHurdleCell(x, y) {
        return hurdles.some((h) => h.x === x && h.y === y);
      }

      const sounds = {
        eat: createBeep(520, 0.08),
        turn: createBeep(280, 0.04),
        crash: createBeep(120, 0.18),
      };

      function createBeep(freq, duration) {
        let audioContext;
        return () => {
          if (!soundEnabled) return;
          if (!audioContext) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
          }
          const osc = audioContext.createOscillator();
          const gain = audioContext.createGain();
          osc.type = 'square';
          osc.frequency.value = freq;
          gain.gain.value = 0.05;
          osc.connect(gain);
          gain.connect(audioContext.destination);
          osc.start();
          osc.stop(audioContext.currentTime + duration);
        };
      }

      function getISOWeekKey(date) {
        const d = new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()));
        const day = d.getUTCDay() || 7;
        d.setUTCDate(d.getUTCDate() + 4 - day);
        const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
        const weekNo = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
        return `${d.getUTCFullYear()}-W${String(weekNo).padStart(2, '0')}`;
      }

      function updateLeaderboardStatus(text) {
        leaderboardStatusEl.textContent = text;
      }

      function setLeaderboardExpanded(expanded) {
        leaderboardExpanded = expanded;
        leaderboardSectionEl.classList.toggle('collapsed', !expanded);
        leaderboardToggleBtn.textContent = expanded ? 'Collapse' : 'Expand';
        leaderboardToggleBtn.setAttribute('aria-expanded', expanded ? 'true' : 'false');
        leaderboardBodyEl.setAttribute('aria-hidden', expanded ? 'false' : 'true');
      }

      function toggleLeaderboardExpanded() {
        if (!isGameOver && !isPaused && !leaderboardExpanded) {
          isPaused = true;
          pauseBtn.textContent = 'Resume';
          setLeaderboardExpanded(true);
          return;
        }
        setLeaderboardExpanded(!leaderboardExpanded);
      }

      function sanitizeName(value) {
        return value.replace(/\s+/g, ' ').trim().slice(0, 10);
      }

      function getReadableSubmitError(error) {
        const code = error && error.code ? String(error.code) : '';
        if (code.includes('permission-denied')) {
          return 'Write blocked by Firestore rules. Allow create on leaderboard collection.';
        }
        if (code.includes('unauthenticated')) {
          return 'Sign-in required by Firestore rules. Relax rules or add auth.';
        }
        if (code.includes('failed-precondition')) {
          return 'Firestore not ready (or required index missing). Check console for setup link.';
        }
        if (code.includes('unavailable')) {
          return 'Network/Firestore temporarily unavailable. Try again.';
        }
        return 'Submission failed. Check Firebase config/rules.';
      }

      function getReadableFetchError(error) {
        const code = error && error.code ? String(error.code) : '';
        if (code.includes('permission-denied')) {
          return 'Read blocked by Firestore rules. Allow read on leaderboard collection.';
        }
        if (code.includes('failed-precondition')) {
          return 'Firestore not ready. Create Firestore Database in Firebase console.';
        }
        if (code.includes('unavailable')) {
          return 'Network/Firestore temporarily unavailable. Try again.';
        }
        return 'Leaderboard unavailable. Check Firebase config/rules.';
      }

      async function clearLeaderboardCollection() {
        while (true) {
          const snapshot = await db.collection(leaderboardCollection).limit(200).get();
          if (snapshot.empty) break;
          const batch = db.batch();
          snapshot.docs.forEach((doc) => batch.delete(doc.ref));
          await batch.commit();
        }
      }

      async function ensureCurrentWeekStorage() {
        const latestSnap = await db.collection(leaderboardCollection)
          .orderBy('createdAtMs', 'desc')
          .limit(1)
          .get();
        if (latestSnap.empty) return;

        const latestWeekKey = latestSnap.docs[0].data().weekKey;
        if (latestWeekKey === currentWeekKey) return;

        updateLeaderboardStatus('Starting new weekly leaderboard...');
        await clearLeaderboardCollection();
      }

      function renderLeaderboard() {
        leaderboardListEl.innerHTML = '';
        if (leaderboardEntries.length === 0) {
          const row = document.createElement('li');
          row.textContent = 'No scores yet this week.';
          leaderboardListEl.appendChild(row);
          return;
        }

        leaderboardEntries.forEach((entry, index) => {
          const row = document.createElement('li');
          const safeName = entry.name || 'Anonymous';
          const rankEl = document.createElement('span');
          const nameEl = document.createElement('span');
          const pointsEl = document.createElement('span');
          rankEl.className = 'rank';
          nameEl.className = 'name';
          pointsEl.className = 'points';
          rankEl.textContent = `#${index + 1}`;
          nameEl.textContent = safeName;
          pointsEl.textContent = String(entry.score);
          row.appendChild(rankEl);
          row.appendChild(nameEl);
          row.appendChild(pointsEl);
          leaderboardListEl.appendChild(row);
        });
      }

      function getQualificationResult(playerScore) {
        if (playerScore <= 0) return { qualifies: false, rank: null };
        if (leaderboardEntries.length < LEADERBOARD_LIMIT) {
          return { qualifies: true, rank: leaderboardEntries.length + 1 };
        }

        const cutoff = leaderboardEntries[leaderboardEntries.length - 1];
        if (!cutoff || playerScore > cutoff.score) {
          const betterCount = leaderboardEntries.filter((entry) => entry.score > playerScore).length;
          return { qualifies: true, rank: betterCount + 1 };
        }

        return { qualifies: false, rank: null };
      }

      async function fetchWeeklyLeaderboard() {
        if (!db) return;
        updateLeaderboardStatus('Refreshing leaderboard...');
        try {
          const snapshot = await db
            .collection(leaderboardCollection)
            .orderBy('score', 'desc')
            .limit(LEADERBOARD_LIMIT)
            .get();

          leaderboardEntries = snapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() }));
          leaderboardEntries.sort((a, b) => {
            if (b.score !== a.score) return b.score - a.score;
            const aTime = typeof a.createdAtMs === 'number' ? a.createdAtMs : Number.MAX_SAFE_INTEGER;
            const bTime = typeof b.createdAtMs === 'number' ? b.createdAtMs : Number.MAX_SAFE_INTEGER;
            return aTime - bTime;
          });
          renderLeaderboard();
          updateLeaderboardStatus(`Showing ${leaderboardEntries.length} / ${LEADERBOARD_LIMIT} this week.`);
        } catch (error) {
          console.error('Failed to load leaderboard:', error);
          updateLeaderboardStatus(getReadableFetchError(error));
        }
      }

      function hideLeaderboardEntryForm() {
        pendingLeaderboardScore = null;
        submittingLeaderboard = false;
        leaderboardSubmitBtn.disabled = false;
        leaderboardEntryForm.style.display = 'none';
        leaderboardNameInput.value = '';
      }

      function showLeaderboardEntryForm(playerScore, rank) {
        pendingLeaderboardScore = playerScore;
        const rankText = rank ? ` (provisional rank #${rank})` : '';
        leaderboardEntryPrompt.textContent = `${getTopLabel()} this week${rankText}. Enter your name:`;
        leaderboardEntryForm.style.display = 'flex';
        leaderboardNameInput.focus();
      }

      async function submitLeaderboardScore(event) {
        event.preventDefault();
        if (!db || pendingLeaderboardScore === null || submittingLeaderboard) return;

        const name = sanitizeName(leaderboardNameInput.value) || 'Anonymous';
        submittingLeaderboard = true;
        leaderboardSubmitBtn.disabled = true;
        updateLeaderboardStatus('Submitting score...');

        try {
          await db.collection(leaderboardCollection).add({
            name,
            score: pendingLeaderboardScore,
            weekKey: currentWeekKey,
            createdAtMs: Date.now(),
            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
          });

          messageEl.innerHTML = `<span class="game-over">Nice run.</span> ${name} added to weekly leaderboard. Press Restart or Enter`;
          hideLeaderboardEntryForm();
          await fetchWeeklyLeaderboard();
        } catch (error) {
          console.error('Failed to submit score:', error);
          leaderboardSubmitBtn.disabled = false;
          submittingLeaderboard = false;
          updateLeaderboardStatus(getReadableSubmitError(error));
        }
      }

      function evaluateLeaderboardAfterGame() {
        if (!leaderboardReady || !db) return;
        const result = getQualificationResult(score);
        if (!result.qualifies) return;

        messageEl.innerHTML = `<span class="game-over">Congrats.</span> You made this week&apos;s ${getTopLabel()}.`;
        showLeaderboardEntryForm(score, result.rank);
      }

      function initLeaderboard() {
        leaderboardTitleEl.textContent = `Weekly ${getTopLabel()}`;
        leaderboardWeekEl.textContent = currentWeekKey;
        const hasConfig = firebaseConfig.apiKey && firebaseConfig.projectId && firebaseConfig.appId;
        if (!window.firebase || !window.firebase.firestore || !hasConfig) {
          updateLeaderboardStatus('Set Firebase config to enable weekly leaderboard.');
          visitorCountEl.textContent = 'Unique visitors: unavailable';
          renderLeaderboard();
          return;
        }

        try {
          if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
          db = firebase.firestore();
          leaderboardReady = true;
          initUniqueVisitorCount();
          ensureCurrentWeekStorage()
            .then(fetchWeeklyLeaderboard)
            .catch((error) => {
              console.error('Weekly leaderboard reset failed:', error);
              updateLeaderboardStatus(getReadableFetchError(error));
            });
        } catch (error) {
          console.error('Firebase init failed:', error);
          updateLeaderboardStatus('Leaderboard unavailable. Firebase init failed.');
          visitorCountEl.textContent = 'Unique visitors: unavailable';
          renderLeaderboard();
        }
      }

      function resetGame() {
        hurdles = buildHurdles();
        const startX = Math.max(2, Math.floor(GRID_COLUMNS / 2));
        const startY = Math.floor(GRID_ROWS / 2);
        snake = [
          { x: startX, y: startY },
          { x: startX - 1, y: startY },
          { x: startX - 2, y: startY },
        ];
        direction = { x: 1, y: 0 };
        nextDirection = { x: 1, y: 0 };
        score = 0;
        updateScore();
        elapsed = 0;
        updateTimer();
        placeFood();
        isGameOver = false;
        isPaused = false;
        messageEl.textContent = 'Eat the glow cubes. Avoid yourself and red hurdles.';
        shareBtn.style.display = 'none';
        pauseBtn.textContent = 'Pause';
        hideLeaderboardEntryForm();
        setLeaderboardExpanded(false);
      }

      function updateScore() {
        scoreEl.textContent = String(score);
      }

      function updateTimer() {
        const remaining = Math.max(0, Math.ceil(GAME_DURATION_SECONDS - elapsed));
        timerEl.textContent = `${remaining}s / ${GAME_DURATION_SECONDS}s`;
      }

      function placeFood() {
        let position;
        do {
          position = {
            x: Math.floor(Math.random() * GRID_COLUMNS),
            y: Math.floor(Math.random() * GRID_ROWS),
          };
        } while (
          snake.some(segment => segment.x === position.x && segment.y === position.y) ||
          isHurdleCell(position.x, position.y)
        );
        food = position;
      }

      function setDirection(newDir) {
        if (isGameOver) return;
        const goingBack = (direction.x + newDir.x === 0 && direction.y + newDir.y === 0);
        if (goingBack) return;
        nextDirection = newDir;
        sounds.turn();
      }

      function gameStep() {
        direction = nextDirection;
        const head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };

        // Wrap around edges (toroidal playfield).
        if (head.x < 0) head.x = GRID_COLUMNS - 1;
        if (head.x >= GRID_COLUMNS) head.x = 0;
        if (head.y < 0) head.y = GRID_ROWS - 1;
        if (head.y >= GRID_ROWS) head.y = 0;

        if (snake.some(segment => segment.x === head.x && segment.y === head.y)) {
          return gameOver();
        }
        if (isHurdleCell(head.x, head.y)) {
          return gameOver('Hit a Hurdle');
        }

        snake.unshift(head);

        if (head.x === food.x && head.y === food.y) {
          score += 1;
          updateScore();
          placeFood();
          sounds.eat();
        } else {
          snake.pop();
        }
      }

      function gameOver(customMessage) {
        if (isGameOver) return;
        isGameOver = true;
        const label = customMessage || 'Game Over';
        messageEl.innerHTML = `<span class="game-over">${label}</span> â€” Press Restart or Enter`;
        shareBtn.style.display = 'block';
        sounds.crash();
        setLeaderboardExpanded(false);
        evaluateLeaderboardAfterGame();
      }

      function getSpeed() {
        return Math.min(maxSpeed, baseSpeed + score * speedStep);
      }

      function update(time) {
        if (!lastTime) lastTime = time;
        const delta = (time - lastTime) / 1000;
        lastTime = time;

        if (!isPaused && !isGameOver) {
          accumulator += delta;
          const step = 1 / getSpeed();
          while (accumulator >= step) {
            gameStep();
            accumulator -= step;
          }
          elapsed += delta;
          updateTimer();
          if (elapsed >= GAME_DURATION_SECONDS) {
            return gameOver('Time Up');
          }
        }

        draw();
        requestAnimationFrame(update);
      }

      function drawCell(x, y, color, glow) {
        const padding = 2;
        const size = gridSize - padding * 2;
        const px = x * gridSize + padding;
        const py = y * gridSize + padding;
        ctx.fillStyle = color;
        if (glow) {
          ctx.shadowColor = color;
          ctx.shadowBlur = 12;
        }
        ctx.fillRect(px, py, size, size);
        ctx.shadowBlur = 0;
      }

      function drawGrid() {
        ctx.strokeStyle = 'rgba(255,255,255,0.04)';
        ctx.lineWidth = 1;
        for (let i = 0; i <= GRID_COLUMNS; i++) {
          const pos = i * gridSize;
          ctx.beginPath();
          ctx.moveTo(pos, 0);
          ctx.lineTo(pos, canvas.height);
          ctx.stroke();
        }
        for (let i = 0; i <= GRID_ROWS; i++) {
          const pos = i * gridSize;
          ctx.beginPath();
          ctx.moveTo(0, pos);
          ctx.lineTo(canvas.width, pos);
          ctx.stroke();
        }
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawGrid();
        drawCell(food.x, food.y, '#19b8ff', true);
        hurdles.forEach((hurdle) => {
          drawCell(hurdle.x, hurdle.y, '#ff5c70', false);
        });

        snake.forEach((segment, index) => {
          const color = index === 0 ? '#35ff8a' : '#1fd17a';
          drawCell(segment.x, segment.y, color, index === 0);
        });

        if (isPaused) {
          ctx.fillStyle = 'rgba(0,0,0,0.6)';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = '#ffffff';
          ctx.font = 'bold 36px Trebuchet MS';
          ctx.textAlign = 'center';
          ctx.fillText('Paused', canvas.width / 2, canvas.height / 2);
        }
      }

      function togglePause() {
        if (isGameOver) return;
        isPaused = !isPaused;
        pauseBtn.textContent = isPaused ? 'Resume' : 'Pause';
        if (!isPaused) setLeaderboardExpanded(false);
      }

      function toggleSound() {
        soundEnabled = !soundEnabled;
        soundBtn.textContent = `Sound: ${soundEnabled ? 'On' : 'Off'}`;
      }

      function shareScore() {
        if (!isGameOver) return;
        const link = window.location.href;
        const text = `I scored ${score} in Neon Snake! Play here: ${link}`;
        const shareUrl = `https://wa.me/?text=${encodeURIComponent(text)}`;
        window.open(shareUrl, '_blank', 'noopener');
      }

      function handleKeydown(event) {
        const tagName = event.target && event.target.tagName;
        if (tagName === 'INPUT' || tagName === 'TEXTAREA') return;

        switch (event.key) {
          case 'ArrowUp':
            event.preventDefault();
            setDirection({ x: 0, y: -1 });
            break;
          case 'ArrowDown':
            event.preventDefault();
            setDirection({ x: 0, y: 1 });
            break;
          case 'ArrowLeft':
            event.preventDefault();
            setDirection({ x: -1, y: 0 });
            break;
          case 'ArrowRight':
            event.preventDefault();
            setDirection({ x: 1, y: 0 });
            break;
          case 'Enter':
            if (isGameOver) resetGame();
            break;
          case ' ':
            togglePause();
            break;
          default:
            break;
        }
      }

      let touchStartX = 0;
      let touchStartY = 0;

      function handleTouchStart(event) {
        const touch = event.changedTouches[0];
        touchStartX = touch.clientX;
        touchStartY = touch.clientY;
      }

      function handleTouchMove(event) {
        if (event.changedTouches.length === 0) return;
        const touch = event.changedTouches[0];
        const diffX = touch.clientX - touchStartX;
        const diffY = touch.clientY - touchStartY;
          const absX = Math.abs(diffX);
          const absY = Math.abs(diffY);

          if (Math.max(absX, absY) < 24) return;

          if (absX > absY) {
            setDirection({ x: diffX > 0 ? 1 : -1, y: 0 });
          } else {
            setDirection({ x: 0, y: diffY > 0 ? 1 : -1 });
          }
          touchStartX = touch.clientX;
          touchStartY = touch.clientY;
      }

      function resizeCanvas() {
        canvas.width = gridSize * GRID_COLUMNS;
        canvas.height = gridSize * GRID_ROWS;
        canvasWrapEl.style.aspectRatio = `${GRID_COLUMNS} / ${GRID_ROWS}`;
      }

      function bindUI() {
        restartBtn.addEventListener('click', () => resetGame());
        pauseBtn.addEventListener('click', () => togglePause());
        soundBtn.addEventListener('click', () => toggleSound());
        shareBtn.addEventListener('click', () => shareScore());
        leaderboardEntryForm.addEventListener('submit', submitLeaderboardScore);
        leaderboardToggleBtn.addEventListener('click', toggleLeaderboardExpanded);

        document.addEventListener('keydown', handleKeydown);

        canvas.addEventListener('touchstart', handleTouchStart, { passive: true });
        canvas.addEventListener('touchmove', handleTouchMove, { passive: true });

        mobileDpadEl.addEventListener('click', (event) => {
          const button = event.target.closest('button[data-dir]');
          if (!button) return;
          const dir = button.dataset.dir;
          if (dir === 'up') setDirection({ x: 0, y: -1 });
          if (dir === 'down') setDirection({ x: 0, y: 1 });
          if (dir === 'left') setDirection({ x: -1, y: 0 });
          if (dir === 'right') setDirection({ x: 1, y: 0 });
        });

      }

      resizeCanvas();
      bindUI();
      setLeaderboardExpanded(true);
      initLeaderboard();
      resetGame();
      requestAnimationFrame(update);
    })();
  </script>
</body>
</html>
